
# Python 中的垃圾回收机制?
Python语言默认采用的垃圾收集机制是 
1 引用计数法
每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，
每当新的引用指向该对象时，它的引用计数ob_ref加1，
每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收
引用计数法最主要的问题是它不能解决对象的“循环引用”
2 标记清除
它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象
『非活动对象』进行回收
3 分代回收
Python将内存根据对象的存活时间划分为不同的集合， 将内存分为了3“代”，分别为年轻代（第0代）、
中年代（第1代）、老年代（第2代），
他们对应的是3个链表，它们的垃圾收集频率随之对象的存活时间的增大而减小。
比如创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，
Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，
而那些不会回收的对象就会被移到中年代去，依此类推


# 装饰器
装饰器 为了适用两个场景，一个是增强被装饰函数的行为，另一个是代码重用。

# 闭包
闭包就是在函数内部再定义一个函数再return出去，了避免了使用全局变量，

# 深拷贝 浅拷贝
浅拷贝拷贝的是引用 深拷贝拷贝的是对象本身

# is 和 == 的区别？